# Translated from account.erl

interface Account_mb {
  Debit(Int, Barrier_mb!),
  Credit(Int, Account_mb!, Barrier_mb!),
  Stop()
}

interface Barrier_mb {
  Reply()
}

interface Main_mb { }

def notify(mb0: Barrier_mb?, barrier: Barrier_mb!): (Unit * Barrier_mb?) {
  (barrier ! Reply(), mb0)
}

def await(mb1: Barrier_mb?): (Unit * Barrier_mb?) {
  let (v0, mb3) =
    guard mb1: Reply {
      receive Reply() from mb2 ->
        ((), mb2)
    }
  in
    (v0, mb3)
}

def account(mb4: Account_mb?, balance: Int): (Unit * Account_mb?) {
  let (v1, mb18) =
    guard mb4: ((*Debit) . (*Credit)) {
      receive Debit(amount, ack) from mb5 ->
        let (v2, mb6) =
          notify(mb5, ack)
        in
          (let mb7 =
  new [Account_mb]
in
  let (x, mb8) =
    account(mb7, balance - amount)
  in
    let y =
      free(mb8)
    in
      x, mb6)
      receive Credit(amount, payer, ack) from mb9 ->
        let (self, mb10) =
          (mb9, mb9)
        in
          let (v3, mb11) =
            (payer ! Debit(amount, self), mb10)
          in
            let (v4, mb14) =
              (let mb12 =
  new [Barrier_mb]
in
  let (x, mb13) =
    await(mb12)
  in
    let y =
      free(mb13)
    in
      x, mb11)
            in
              let (v5, mb15) =
                notify(mb14, ack)
              in
                (let mb16 =
  new [Account_mb]
in
  let (x, mb17) =
    account(mb16, balance + amount)
  in
    let y =
      free(mb17)
    in
      x, mb15)
    }
  in
    (v1, mb18)
}

def main(mb19: Main_mb?): (Unit * Main_mb?) {
  let (alice, mb22) =
    (let mb20 =
  new [Account_mb]
in
  let y =
    spawn {
      let (x, mb21) =
        account(mb20, 10)
      in
        free(mb21)
    }
  in
    mb20, mb19)
  in
    let (bob, mb25) =
      (let mb23 =
  new [Account_mb]
in
  let y =
    spawn {
      let (x, mb24) =
        account(mb23, 15)
      in
        free(mb24)
    }
  in
    mb23, mb22)
    in
      let (self, mb26) =
        (mb25, mb25)
      in
        let (v6, mb27) =
          (alice ! Credit(10, bob, self), mb26)
        in
          (let mb28 =
  new [Barrier_mb]
in
  let (x, mb29) =
    await(mb28)
  in
    let y =
      free(mb29)
    in
      x, mb27)
}

def main'(): Unit {
  let mb30 =
    new [Main_mb]
  in
    let (x, mb31) =
      main(mb30)
    in
      let y =
        free(mb31)
      in
        x
}