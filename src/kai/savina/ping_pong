# Translated from ping_pong.erl

interface Ping_mb {
  Start(),
  Pong()
}

interface Pong_mb {
  Ping(Ping_mb!),
  Stop()
}

interface Main_mb { }

def ping(mb0: Ping_mb?, pong: Pong_mb!, pings_left: Int): (Unit * Ping_mb?) {
  let (v0, mb2) =
    guard mb0: Start {
      receive Start() from mb1 ->
        ping_loop(mb1, pong, pings_left)
    }
  in
    (v0, mb2)
}

def ping_loop(mb3: Ping_mb?, pong: Pong_mb!, pings_left: Int): (Unit * Ping_mb?) {
  let (self, mb4) =
    (mb3, mb3)
  in
    let (v1, mb9) =
      if (pings_left > 0) {
        let (v2, mb5) =
          (pong ! Ping(self), mb4)
        in
          let (v3, mb8) =
            guard mb5: Pong + 1 {
              empty(mb7) ->
                ((), mb7)
              receive Pong() from mb6 ->
                ping_loop(mb6, pong, pings_left - 1)
            }
          in
            (v3, mb8)
      }
      else {
        (pong ! Stop(), mb4)
      }
    in
      (v1, mb9)
}

def pong(mb10: Pong_mb?): (Unit * Pong_mb?) {
  let (v4, mb17) =
    guard mb10: *(Ping + Stop) {
      empty(mb16) ->
        ((), mb16)
      receive Ping(ping) from mb11 ->
        let (v5, mb12) =
          (ping ! Pong(), mb11)
        in
          (let mb13 =
  new [Pong_mb]
in
  let (x, mb14) =
    pong(mb13)
  in
    let y =
      free(mb14)
    in
      x, mb12)
      receive Stop() from mb15 ->
        pong_exit(mb15)
    }
  in
    (v4, mb17)
}

def pong_exit(mb18: Pong_mb?): (Unit * Pong_mb?) {
  let (v6, mb22) =
    guard mb18: *(Ping + Stop) {
      empty(mb21) ->
        ((), mb21)
      receive Ping(ping) from mb19 ->
        pong_exit(mb19)
      receive Stop() from mb20 ->
        pong_exit(mb20)
    }
  in
    (v6, mb22)
}

def main(mb23: Main_mb?): (Unit * Main_mb?) {
  let (pong, mb26) =
    (let mb24 =
  new [Pong_mb]
in
  let y =
    spawn {
      let (x, mb25) =
        pong(mb24)
      in
        free(mb25)
    }
  in
    mb24, mb23)
  in
    let (ping, mb29) =
      (let mb27 =
  new [Ping_mb]
in
  let y =
    spawn {
      let (x, mb28) =
        ping(mb27, pong, 5)
      in
        free(mb28)
    }
  in
    mb27, mb26)
    in
      (ping ! Start(), mb29)
}

def main'(): Unit {
  let mb30 =
    new [Main_mb]
  in
    let (x, mb31) =
      main(mb30)
    in
      let y =
        free(mb31)
      in
        x
}