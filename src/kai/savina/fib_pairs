# Translated from fib_pairs.erl

interface Fib_actor_mb {
  Request(Int, Fib_actor_mb!),
  Response(Int)
}

def fib_actor(mb0: Fib_actor_mb?): (Unit * Fib_actor_mb?) {
  let (v0, mb29) =
    guard mb0: Request {
      receive Request(n, parent) from mb1 ->
        let (v1, mb28) =
          if (n <= 2) {
            (parent ! Response(1), mb1)
          }
          else {
            let (self, mb15) =
              (mb1, mb1)
            in
              let (child1, mb18) =
                (let mb16 =
  new [Fib_actor_mb]
in
  let y =
    spawn {
      let (x, mb17) =
        fib_actor(mb16)
      in
        free(mb17)
    }
  in
    mb16, mb15)
              in
                let (v2, mb19) =
                  (child1 ! Request(n - 1, self), mb18)
                in
                  let (child2, mb22) =
                    (let mb20 =
  new [Fib_actor_mb]
in
  let y =
    spawn {
      let (x, mb21) =
        fib_actor(mb20)
      in
        free(mb21)
    }
  in
    mb20, mb19)
                  in
                    let (v3, mb23) =
                      (child2 ! Request(n - 2, self), mb22)
                    in
                      let (term1, mb25) =
                        guard mb23: Response {
                          receive Response(x1) from mb24 ->
                            (x1, mb24)
                        }
                      in
                        let (term2, mb27) =
                          guard mb25: Response {
                            receive Response(x2) from mb26 ->
                              (x2, mb26)
                          }
                        in
                          (parent ! Response(term1 + term2), mb27)
          }
        in
          (v1, mb28)
    }
  in
    (v0, mb29)
}

def main(mb30: Fib_actor_mb?, n: Int): (Int * Fib_actor_mb?) {
  let (self, mb31) =
    (mb30, mb30)
  in
    let (first_actor, mb34) =
      (let mb32 =
  new [Fib_actor_mb]
in
  let y =
    spawn {
      let (x, mb33) =
        fib_actor(mb32)
      in
        free(mb33)
    }
  in
    mb32, mb31)
    in
      let (v4, mb35) =
        (first_actor ! Request(n, self), mb34)
      in
        let (v5, mb37) =
          guard mb35: Response {
            receive Response(x) from mb36 ->
              (x, mb36)
          }
        in
          (v5, mb37)
}

def main'(): Unit {
  let mb38 =
    new [Main_mb]
  in
    let (x, mb39) =
      main(mb38)
    in
      let y =
        free(mb39)
      in
        x
}