# Translated from count.erl

interface Producer_mb {
  Inc(),
  Total(Int)
}

interface Counter_mb {
  Inc(),
  Get(Producer_mb!)
}

interface Main_mb { }

def producer(mb0: Producer_mb?, counter: Counter_mb!, num_messages: Int): (Unit * Producer_mb?) {
  let (v0, mb2) =
    guard mb0: Inc {
      receive Inc() from mb1 ->
        producer_loop(mb1, counter, num_messages)
    }
  in
    (v0, mb2)
}

def producer_loop(mb3: Producer_mb?, counter: Counter_mb!, num_messages: Int): (Unit * Producer_mb?) {
  let (self, mb4) =
    (mb3, mb3)
  in
    let (v1, mb8) =
      if (num_messages <= 0) {
        let (v2, mb5) =
          (counter ! Get(self), mb4)
        in
          producer_exit(mb5, num_messages)
      }
      else {
        let (v3, mb7) =
          (counter ! Inc(), mb4)
        in
          producer_loop(mb7, counter, num_messages - 1)
      }
    in
      (v1, mb8)
}

def producer_exit(mb9: Producer_mb?, num_messages: Int): (Unit * Producer_mb?) {
  let (v4, mb11) =
    guard mb9: Total {
      receive Total(total) from mb10 ->
        ((), mb10)
    }
  in
    (v4, mb11)
}

def counter(mb12: Counter_mb?, total: Int): (Unit * Counter_mb?) {
  let (v5, mb18) =
    guard mb12: (*Inc) . Get {
      receive Inc() from mb13 ->
        (let mb14 =
  new [Counter_mb]
in
  let (x, mb15) =
    counter(mb14, total + 1)
  in
    let y =
      free(mb15)
    in
      x, mb13)
      receive Get(producer) from mb16 ->
        let (v6, mb17) =
          (producer ! Total(total), mb16)
        in
          counter_exit(mb17)
    }
  in
    (v5, mb18)
}

def counter_exit(mb19: Counter_mb?): (Unit * Counter_mb?) {
  let (v7, mb22) =
    guard mb19: *Inc {
      empty(mb21) ->
        ((), mb21)
      receive Inc() from mb20 ->
        counter_exit(mb20)
    }
  in
    (v7, mb22)
}

def main(mb23: Main_mb?): (Unit * Main_mb?) {
  let (counter, mb26) =
    (let mb24 =
  new [Counter_mb]
in
  let y =
    spawn {
      let (x, mb25) =
        counter(mb24, 0)
      in
        free(mb25)
    }
  in
    mb24, mb23)
  in
    let (producer, mb29) =
      (let mb27 =
  new [Producer_mb]
in
  let y =
    spawn {
      let (x, mb28) =
        producer(mb27, counter, 5)
      in
        free(mb28)
    }
  in
    mb27, mb26)
    in
      (producer ! Inc(), mb29)
}

def main'(): Unit {
  let mb30 =
    new [Main_mb]
  in
    let (x, mb31) =
      main(mb30)
    in
      let y =
        free(mb31)
      in
        x
}